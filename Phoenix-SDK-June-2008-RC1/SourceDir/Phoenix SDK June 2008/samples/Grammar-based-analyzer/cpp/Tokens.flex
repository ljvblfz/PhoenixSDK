
/* Scanner for Grammar.y */

/* The scanner that is generated implements yylex, which is invoked by the yacc parser to retrieve */
/* tokens from the input stream. */

%{

#include "Scanner.h"

// Token declarations are generated by yacc (using option -d).
#include "YaccDeclarations.h"

// Rename deprecated POSIX function.
#define fileno _fileno

// Rename isatty and import it from msvcrt.dll.
// Note: If the scanner is not expected to read its input from the console, then
//       it is simpler and more efficient to insert a definition like the following:
// inline static int isatty(int fd) { return 0; }

#define isatty _isatty

[System::Runtime::InteropServices::DllImport("msvcrt.dll")]
extern "C"
{
   int _isatty(int fd);
}

// Global variables.
int LineNumber = 1;

// Handling of string literals.
#define MAX_LITERAL_LENGTH 120
static char literalBuf[MAX_LITERAL_LENGTH + 1];
static char* literalPtr;

static void AddCharToLiteral(char c);

// Local utilities.

inline static void SetTextYylval()
{
   yylval.Text.tokenStart = yytext;
   yylval.Text.tokenLength = yyleng;
}

%}

/* Start condition for reading a string literal. */
%x LIT

/* Character classes. */
DIGIT    [0-9]
ID       [a-zA-Z_][a-zA-Z0-9_]*

%%

{DIGIT}+    { 
              yylval.IntVal = atoi(yytext);
              return NUMBER;
            }

if          return IF; 

then        return THEN; 

else        return ELSE; 

"=="        return EQ;

"!="        return NE;

"="         return GETS;

">"         return GT;

">="        return GE;

"<"         return LT;

"<="        return LE;

false       return FALSE;

true        return TRUE;

and         return AND;

or          return OR;

not         return NOT;

return      return RETURN;

int         {
               yylval.SymbolType = (int)SymbolType::Int;
               return INT;
            }
            

string      {
               yylval.SymbolType = (int)SymbolType::String;
               return STRING;
            }
            

bool        {
               yylval.SymbolType = (int)SymbolType::Boolean;
               return BOOL;
            }
            

{ID}        {
               SetTextYylval();
               return ID;
            }


\"          {
               BEGIN LIT;
               literalPtr = literalBuf;
            }

\/\/.*$     /* eat up comments */

[ \t]+      /* eat up whitespace */

\n          ++LineNumber;

.           {
               // By default, return a literal token, e.g. ';' or '{', etc.
               return *yytext;
            }


<LIT>\n     {
               *literalPtr = 0;
               fprintf(stderr, "Error line %d: Incomplete string literal \"%s.\n", LineNumber, literalBuf);
               exit(1);
            }

<LIT>\\[0-7]{1,3} {
               // Store escaped sequence as is.
               for (int i = 0; i < yyleng; ++i)
                 AddCharToLiteral(yytext[i]);
            }

<LIT>\\[0-9]+ {
               fprintf(stderr, "Error line %d: Bad escape sequence '%.*s' in string literal.\n", yyleng, yytext);
               exit(1);
            }

<LIT>\\.    {
               // Store escaped character as is.
            	AddCharToLiteral(yytext[0]);
            	AddCharToLiteral(yytext[1]);
            }

<LIT>[^\\\"\n]+   {
               for (int i = 0; i < yyleng; ++i)
                  AddCharToLiteral(yytext[i]);
            }

<LIT>\"     {
               *literalPtr = 0;
               yylval.Text.tokenStart = literalBuf;
               yylval.Text.tokenLength = literalPtr - literalBuf;
               BEGIN INITIAL;
               return STRING_LITERAL;
            }

%%

void InitScanner(int argc, char* argv[])
{
  ++argv, --argc;  /* skip over program name */
  if ( argc > 0 )
  {
     yyin = fopen( argv[0], "r");
     if (yyin == 0)
     {
        fprintf(stderr, "Cannot open file %s.\n", argv[0]);
        exit(1);
     }
  }
  else
     yyin = stdin;
}

// yywrap is invoked at EOF.
// It will either redirect yyin to a new stream and return 0, or do nothing and return nonzero.
int yywrap()
{
    return 1;
}

static void AddCharToLiteral(char c)
{
   if (literalPtr - literalBuf >= MAX_LITERAL_LENGTH)
   {
      fprintf(stderr, "Error line %d: String literal exceeds maximum length of %d characters.\n", LineNumber, MAX_LITERAL_LENGTH);
      exit(1);
   }

   *literalPtr++ = c;
}

