%{
/*
 * pascal.l
 *
 * lex input file for pascal scanner
 *
 * extensions: two ways to spell "external" and "->" ok for "^".
 */
#include <stdio.h>
#include <errno.h>

#include "Scanner.h"

// Token declarations are generated by yacc (using option -d).
#include "YaccDeclarations.h"

// Rename deprecated POSIX function.
#define fileno _fileno

// Rename isatty and import it from msvcrt.dll.
// Note: If the scanner is not expected to read its input from the console, then
//       it is simpler and more efficient to insert a definition like the following:
// inline static int isatty(int fd) { return 0; }

#define isatty _isatty

[System::Runtime::InteropServices::DllImport("msvcrt.dll")]
extern "C"
{
   int _isatty(int fd);
}

// Global variables.
int LineNum = 1;

// Handling of string literals.
#define MAX_LITERAL_LENGTH 120
static char literalBuf[MAX_LITERAL_LENGTH + 1];
static char* literalPtr;

static void AddCharToLiteral(char c);

void commenteof();

// Local utilities.

inline static void SetTextYylval()
{
   yylval.Text.tokenStart = yytext;
   yylval.Text.tokenLength = yyleng;
}

void yyerror(char *s);

inline static void SetIntYylval()
{
   yylval.IntVal = atoi(yytext);
   if (errno == ERANGE)
   {
      yyerror("out-of-range integer constant.");
      yylval.IntVal = 0;
   }
}

inline static void SetRealYylval()
{	
   yylval.RealVal = atof(yytext);
   if (errno == ERANGE)
   {
      yyerror("out-of-range real constant.");
      yylval.RealVal = 0.0;
   }
}

%}

A [aA]
B [bB]
C [cC]
D [dD]
E [eE]
F [fF]
G [gG]
H [hH]
I [iI]
J [jJ]
K [kK]
L [lL]
M [mM]
N [nN]
O [oO]
P [pP]
Q [qQ]
R [rR]
S [sS]
T [tT]
U [uU]
V [vV]
W [wW]
X [xX]
Y [yY]
Z [zZ]
NQUOTE [^']

%%

{A}{N}{D}   return(AND);
{A}{R}{R}{A}{Y}   return(ARRAY);
{C}{A}{S}{E}   return(CASE);
{C}{O}{N}{S}{T}   return(CONST);
{D}{I}{V}   return(DIV);
{D}{O}    return(DO);
{D}{O}{W}{N}{T}{O}  { SetTextYylval(); return(DOWNTO); }
{E}{L}{S}{E}   return(ELSE);
{E}{N}{D}   return(END);
{E}{X}{T}{E}{R}{N} |
{E}{X}{T}{E}{R}{N}{A}{L} {	SetTextYylval(); 
	return(EXTERNAL); 
}
{F}{O}{R}   return(FOR);
{F}{O}{R}{W}{A}{R}{D}  { SetTextYylval();
	return(FORWARD);
}
{F}{U}{N}{C}{T}{I}{O}{N} return(FUNCTION);
{G}{O}{T}{O}   return(GOTO);
{I}{F}    return(IF);
{I}{N}    return(IN);
{L}{A}{B}{E}{L}   return(LABEL);
{M}{O}{D}   return(MOD);
{N}{I}{L}   return(NIL);
{N}{O}{T}   return(NOT);
{O}{F}    return(OF);
{O}{R}    return(OR);
{O}{T}{H}{E}{R}{W}{I}{S}{E} return(OTHERWISE);
{P}{A}{C}{K}{E}{D}  return(PACKED);
{B}{E}{G}{I}{N}   return(PBEGIN);
{F}{A}{L}{S}{E} return (BFALSE);
{F}{I}{L}{E}   return(PFILE);
{P}{R}{O}{C}{E}{D}{U}{R}{E} return(PROCEDURE);
{P}{R}{O}{G}{R}{A}{M}  return(PROGRAM);
{R}{E}{C}{O}{R}{D}  return(RECORD);
{R}{E}{P}{E}{A}{T}  return(REPEAT);
{S}{E}{T}   return(SET);
{T}{H}{E}{N}   return(THEN);
{T}{O}    { SetTextYylval(); return(TO); }
{T}{R}{U}{E} return (BTRUE);
{T}{Y}{P}{E}   return(TYPE);
{U}{N}{T}{I}{L}   return(UNTIL);
{V}{A}{R}   return(VAR);
{W}{H}{I}{L}{E}   return(WHILE);
{W}{I}{T}{H}   return(WITH);
[a-zA-Z_][a-zA-Z0-9_]* {	SetTextYylval();
		return (IDENTIFIER);	
	}

":="    return(ASSIGNMENT);
'({NQUOTE}|'')+' { SetTextYylval();
		return(CHARACTER_STRING);
	}
":"    return(COLON);
","    return(COMMA);
[0-9]+ {  SetIntYylval(); 
		return(DIGSEQ);
	}
"."    return(DOT);
".."    return(DOTDOT);
"="    return(EQUAL);
">="    return(GE);
">"    return(GT);
"["    return(LBRAC);
"<="    return(LE);
"("    return(LPAREN);
"<"    return(LT);
"-"    return(MINUS);
"<>"    return(NOTEQUAL);
"+"    return(PLUS);
"]"    return(RBRAC);
[0-9]+"."[0-9]+ {	SetRealYylval();
	   return(REALNUMBER);
	}
[0-9]+("."[0-9]+)?({E}("-"|"+")[0-9]+) {	SetRealYylval();
	   return(REALNUMBER);
	}
")"    return(RPAREN);
";"    return(SEMICOLON);
"/"    return(SLASH);
"*"    return(STAR);
"**"    return(STARSTAR);
"->"   |
"^"    { SetTextYylval();	return(UPARROW); }
"(*"   |
"{"    { register int c;
     while ((c = yyinput()))
     {
      if (c == '}')
       break;
      else if (c == '*')
      {
       if ((c = yyinput()) == ')')
        break;
       else
        unput (c);
      }
      else if (c == '\n')
       /*line_no*/LineNum++;
      else if (c == 0)
       commenteof();
     }
    }

[ \t\f]    ;

\n    /*line_no*/LineNum++;

.    { fprintf (stderr,
    "'%c' (0%o): illegal charcter at line %d\n",
     yytext[0], yytext[0], /*line_no*/LineNum);
    }

%%

void commenteof()
{
 fprintf (stderr, "unexpected EOF inside comment at line %d\n",
  /*line_no*/LineNum);
 exit (1);
}

// yywrap is invoked at EOF.
// It will either redirect yyin to a new stream and return 0, or do nothing and return nonzero.
int yywrap ()
{
 return (1);
}

bool InitScanner(char* file_name)
{
   yyin = 0;
   fopen_s(&yyin, file_name, "r");
   if (yyin == 0)
   {   
      return false;
   }
   return true;
}

static void AddCharToLiteral(char c)
{
   if (literalPtr - literalBuf >= MAX_LITERAL_LENGTH)
   {
      fprintf(stderr, "Error line %d: String literal exceeds maximum length of %d characters.\n", LineNum, MAX_LITERAL_LENGTH);
      exit(1);
   }

   *literalPtr++ = c;
}

