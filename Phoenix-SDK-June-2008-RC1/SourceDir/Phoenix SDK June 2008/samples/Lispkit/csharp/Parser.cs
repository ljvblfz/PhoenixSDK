// This code was generated by the Managed Package Parser Generator


using System;
using System.Collections.Generic;
using System.Text;
using Babel.ParserGenerator;
using Lispkit.Ast;

namespace LexParser
{
public enum Tokens {error=125,EOF=126,IDENTIFIER=127,INTEGER=128,LPAREN=129,RPAREN=130,ADD=131,SUB=132,MUL=133,DIV=134,REM=135,NIL=136,QUOTE=137,EQ=138,LEQ=139,CAR=140,CDR=141,ATOM=142,CONS=143,IF=144,LAMBDA=145,LET=146,LETREC=147,UMINUS=148,maxParseToken=int.MaxValue};

public struct ValueType
{   
  internal string StringValue;
  internal int IntValue;  
  internal AritOp Op;  
  internal Node ObjectRef;
  internal Tokens TokenValue; 
}
// Abstract base class to allow overriding of Get/SetEolState
public abstract class ScanBase : AScanner<ValueType,LexLocation>, IColorScan
{
    protected int currentScOrd;
    public virtual int GetEolState() { return currentScOrd; }
    public virtual void SetEolState(int value) { currentScOrd = value; }
    public abstract void SetSource(string s, int o);
    public abstract int GetNext(ref int c, out int s, out int e);
}

public class Parser: ShiftReduceParser<ValueType, LexLocation>
{


private int LineNumber
{
	get { return (this.scanner as LexScanner.Scanner).LineNumber; }
}

private int ColumnNumber
{
	get { return (this.scanner as LexScanner.Scanner).ColumnNumber; }
}

internal Node AstRootNode
{
	get { return astRootNode; }
}

private Node astRootNode = null;

  protected override void Initialize()
  {
    this.errToken = (int)Tokens.error;
    this.eofToken = (int)Tokens.EOF;

    states=new State[151];
    AddState(0,new State(new int[]{129,3},new int[]{-1,1}));
    AddState(1,new State(new int[]{126,2}));
    AddState(2,new State(-1));
    AddState(3,new State(new int[]{147,10,146,101,145,20},new int[]{-25,4,-22,6,-21,8}));
    AddState(4,new State(new int[]{130,5}));
    AddState(5,new State(-94));
    AddState(6,new State(new int[]{130,7}));
    AddState(7,new State(-95));
    AddState(8,new State(new int[]{130,9}));
    AddState(9,new State(-96));
    AddState(10,new State(new int[]{127,24,129,25},new int[]{-10,11,-4,23}));
    AddState(11,new State(new int[]{129,15,130,-81},new int[]{-26,12,-27,13}));
    AddState(12,new State(-80));
    AddState(13,new State(new int[]{129,15,130,-83},new int[]{-26,14,-27,13}));
    AddState(14,new State(-82));
    AddState(15,new State(new int[]{127,24},new int[]{-4,16}));
    AddState(16,new State(new int[]{46,17,145,20},new int[]{-21,149}));
    AddState(17,new State(new int[]{145,20},new int[]{-21,18}));
    AddState(18,new State(new int[]{130,19}));
    AddState(19,new State(-84));
    AddState(20,new State(new int[]{129,143},new int[]{-8,21}));
    AddState(21,new State(new int[]{127,24,129,25},new int[]{-10,22,-4,23}));
    AddState(22,new State(-74));
    AddState(23,new State(-32));
    AddState(24,new State(-21));
    AddState(25,new State(new int[]{137,52,138,82,139,85,140,88,141,90,142,92,143,94,144,97,145,20,146,101,147,10,127,24,129,127,131,138,132,139,133,140,134,141,135,142},new int[]{-12,26,-13,28,-15,30,-16,32,-17,34,-18,36,-19,38,-20,40,-21,42,-22,44,-25,46,-2,48,-14,50,-29,122,-4,126,-31,135}));
    AddState(26,new State(new int[]{130,27}));
    AddState(27,new State(-33));
    AddState(28,new State(new int[]{130,29}));
    AddState(29,new State(-34));
    AddState(30,new State(new int[]{130,31}));
    AddState(31,new State(-35));
    AddState(32,new State(new int[]{130,33}));
    AddState(33,new State(-36));
    AddState(34,new State(new int[]{130,35}));
    AddState(35,new State(-37));
    AddState(36,new State(new int[]{130,37}));
    AddState(37,new State(-38));
    AddState(38,new State(new int[]{130,39}));
    AddState(39,new State(-39));
    AddState(40,new State(new int[]{130,41}));
    AddState(41,new State(-40));
    AddState(42,new State(new int[]{130,43}));
    AddState(43,new State(-41));
    AddState(44,new State(new int[]{130,45}));
    AddState(45,new State(-42));
    AddState(46,new State(new int[]{130,47}));
    AddState(47,new State(-43));
    AddState(48,new State(new int[]{130,49}));
    AddState(49,new State(-44));
    AddState(50,new State(new int[]{130,51}));
    AddState(51,new State(-45));
    AddState(52,new State(new int[]{127,24,128,59,129,60,131,65,132,66,133,67,134,68,135,69,136,70,137,71,138,72,139,73,140,74,141,75,142,76,143,77,144,78,145,79,146,80,147,81},new int[]{-6,53,-32,54,-3,55,-4,56,-5,57,-30,58}));
    AddState(53,new State(-59));
    AddState(54,new State(-60));
    AddState(55,new State(-24));
    AddState(56,new State(-19));
    AddState(57,new State(-20));
    AddState(58,new State(-22));
    AddState(59,new State(-23));
    AddState(60,new State(new int[]{127,24,128,59,129,60},new int[]{-7,61,-6,63,-3,55,-4,56,-5,57,-30,58}));
    AddState(61,new State(new int[]{130,62}));
    AddState(62,new State(-25));
    AddState(63,new State(new int[]{127,24,128,59,129,60,130,-26},new int[]{-7,64,-6,63,-3,55,-4,56,-5,57,-30,58}));
    AddState(64,new State(-27));
    AddState(65,new State(-2));
    AddState(66,new State(-3));
    AddState(67,new State(-4));
    AddState(68,new State(-5));
    AddState(69,new State(-6));
    AddState(70,new State(-7));
    AddState(71,new State(-8));
    AddState(72,new State(-9));
    AddState(73,new State(-10));
    AddState(74,new State(-11));
    AddState(75,new State(-12));
    AddState(76,new State(-13));
    AddState(77,new State(-14));
    AddState(78,new State(-15));
    AddState(79,new State(-16));
    AddState(80,new State(-17));
    AddState(81,new State(-18));
    AddState(82,new State(new int[]{127,24,129,25},new int[]{-10,83,-4,23}));
    AddState(83,new State(new int[]{127,24,129,25},new int[]{-10,84,-4,23}));
    AddState(84,new State(-61));
    AddState(85,new State(new int[]{127,24,129,25},new int[]{-10,86,-4,23}));
    AddState(86,new State(new int[]{127,24,129,25},new int[]{-10,87,-4,23}));
    AddState(87,new State(-68));
    AddState(88,new State(new int[]{127,24,129,25},new int[]{-10,89,-4,23}));
    AddState(89,new State(-69));
    AddState(90,new State(new int[]{127,24,129,25},new int[]{-10,91,-4,23}));
    AddState(91,new State(-70));
    AddState(92,new State(new int[]{127,24,129,25},new int[]{-10,93,-4,23}));
    AddState(93,new State(-71));
    AddState(94,new State(new int[]{127,24,129,25},new int[]{-10,95,-4,23}));
    AddState(95,new State(new int[]{127,24,129,25},new int[]{-10,96,-4,23}));
    AddState(96,new State(-72));
    AddState(97,new State(new int[]{127,24,129,25},new int[]{-10,98,-4,23}));
    AddState(98,new State(new int[]{127,24,129,25},new int[]{-10,99,-4,23}));
    AddState(99,new State(new int[]{127,24,129,25},new int[]{-10,100,-4,23}));
    AddState(100,new State(-73));
    AddState(101,new State(new int[]{127,24,129,25},new int[]{-10,102,-4,23}));
    AddState(102,new State(new int[]{129,106,130,-76},new int[]{-23,103,-24,104}));
    AddState(103,new State(-75));
    AddState(104,new State(new int[]{129,106,130,-78},new int[]{-23,105,-24,104}));
    AddState(105,new State(-77));
    AddState(106,new State(new int[]{127,24},new int[]{-4,107}));
    AddState(107,new State(new int[]{137,52,138,82,139,85,140,88,141,90,142,92,143,94,144,97,145,20,146,101,147,10,127,24,129,127,131,138,132,139,133,140,134,141,135,142},new int[]{-11,108,-12,110,-13,111,-15,112,-16,113,-17,114,-18,115,-19,116,-20,117,-21,118,-22,119,-25,120,-2,121,-29,122,-4,126,-14,134,-31,135}));
    AddState(108,new State(new int[]{130,109}));
    AddState(109,new State(-79));
    AddState(110,new State(-46));
    AddState(111,new State(-47));
    AddState(112,new State(-48));
    AddState(113,new State(-49));
    AddState(114,new State(-50));
    AddState(115,new State(-51));
    AddState(116,new State(-52));
    AddState(117,new State(-53));
    AddState(118,new State(-54));
    AddState(119,new State(-55));
    AddState(120,new State(-56));
    AddState(121,new State(-57));
    AddState(122,new State(new int[]{127,24,129,25,130,-87},new int[]{-28,123,-10,124,-4,23}));
    AddState(123,new State(-86));
    AddState(124,new State(new int[]{127,24,129,25,130,-89},new int[]{-28,125,-10,124,-4,23}));
    AddState(125,new State(-88));
    AddState(126,new State(-90));
    AddState(127,new State(new int[]{145,20,146,101,147,10},new int[]{-21,128,-22,130,-25,132}));
    AddState(128,new State(new int[]{130,129}));
    AddState(129,new State(-91));
    AddState(130,new State(new int[]{130,131}));
    AddState(131,new State(-92));
    AddState(132,new State(new int[]{130,133}));
    AddState(133,new State(-93));
    AddState(134,new State(-58));
    AddState(135,new State(new int[]{127,24,129,25},new int[]{-10,136,-4,23}));
    AddState(136,new State(new int[]{127,24,129,25},new int[]{-10,137,-4,23}));
    AddState(137,new State(-62));
    AddState(138,new State(-63));
    AddState(139,new State(-64));
    AddState(140,new State(-65));
    AddState(141,new State(-66));
    AddState(142,new State(-67));
    AddState(143,new State(new int[]{130,144,127,24},new int[]{-9,145,-4,147}));
    AddState(144,new State(-28));
    AddState(145,new State(new int[]{130,146}));
    AddState(146,new State(-29));
    AddState(147,new State(new int[]{127,24,130,-30},new int[]{-9,148,-4,147}));
    AddState(148,new State(-31));
    AddState(149,new State(new int[]{130,150}));
    AddState(150,new State(-85));

    rules=new Rule[97];
    rules[1]=new Rule(-33, new int[]{-1,126});
    rules[2]=new Rule(-32, new int[]{131});
    rules[3]=new Rule(-32, new int[]{132});
    rules[4]=new Rule(-32, new int[]{133});
    rules[5]=new Rule(-32, new int[]{134});
    rules[6]=new Rule(-32, new int[]{135});
    rules[7]=new Rule(-32, new int[]{136});
    rules[8]=new Rule(-32, new int[]{137});
    rules[9]=new Rule(-32, new int[]{138});
    rules[10]=new Rule(-32, new int[]{139});
    rules[11]=new Rule(-32, new int[]{140});
    rules[12]=new Rule(-32, new int[]{141});
    rules[13]=new Rule(-32, new int[]{142});
    rules[14]=new Rule(-32, new int[]{143});
    rules[15]=new Rule(-32, new int[]{144});
    rules[16]=new Rule(-32, new int[]{145});
    rules[17]=new Rule(-32, new int[]{146});
    rules[18]=new Rule(-32, new int[]{147});
    rules[19]=new Rule(-3, new int[]{-4});
    rules[20]=new Rule(-3, new int[]{-5});
    rules[21]=new Rule(-4, new int[]{127});
    rules[22]=new Rule(-5, new int[]{-30});
    rules[23]=new Rule(-30, new int[]{128});
    rules[24]=new Rule(-6, new int[]{-3});
    rules[25]=new Rule(-6, new int[]{129,-7,130});
    rules[26]=new Rule(-7, new int[]{-6});
    rules[27]=new Rule(-7, new int[]{-6,-7});
    rules[28]=new Rule(-8, new int[]{129,130});
    rules[29]=new Rule(-8, new int[]{129,-9,130});
    rules[30]=new Rule(-9, new int[]{-4});
    rules[31]=new Rule(-9, new int[]{-4,-9});
    rules[32]=new Rule(-10, new int[]{-4});
    rules[33]=new Rule(-10, new int[]{129,-12,130});
    rules[34]=new Rule(-10, new int[]{129,-13,130});
    rules[35]=new Rule(-10, new int[]{129,-15,130});
    rules[36]=new Rule(-10, new int[]{129,-16,130});
    rules[37]=new Rule(-10, new int[]{129,-17,130});
    rules[38]=new Rule(-10, new int[]{129,-18,130});
    rules[39]=new Rule(-10, new int[]{129,-19,130});
    rules[40]=new Rule(-10, new int[]{129,-20,130});
    rules[41]=new Rule(-10, new int[]{129,-21,130});
    rules[42]=new Rule(-10, new int[]{129,-22,130});
    rules[43]=new Rule(-10, new int[]{129,-25,130});
    rules[44]=new Rule(-10, new int[]{129,-2,130});
    rules[45]=new Rule(-10, new int[]{129,-14,130});
    rules[46]=new Rule(-11, new int[]{-12});
    rules[47]=new Rule(-11, new int[]{-13});
    rules[48]=new Rule(-11, new int[]{-15});
    rules[49]=new Rule(-11, new int[]{-16});
    rules[50]=new Rule(-11, new int[]{-17});
    rules[51]=new Rule(-11, new int[]{-18});
    rules[52]=new Rule(-11, new int[]{-19});
    rules[53]=new Rule(-11, new int[]{-20});
    rules[54]=new Rule(-11, new int[]{-21});
    rules[55]=new Rule(-11, new int[]{-22});
    rules[56]=new Rule(-11, new int[]{-25});
    rules[57]=new Rule(-11, new int[]{-2});
    rules[58]=new Rule(-11, new int[]{-14});
    rules[59]=new Rule(-12, new int[]{137,-6});
    rules[60]=new Rule(-12, new int[]{137,-32});
    rules[61]=new Rule(-13, new int[]{138,-10,-10});
    rules[62]=new Rule(-14, new int[]{-31,-10,-10});
    rules[63]=new Rule(-31, new int[]{131});
    rules[64]=new Rule(-31, new int[]{132});
    rules[65]=new Rule(-31, new int[]{133});
    rules[66]=new Rule(-31, new int[]{134});
    rules[67]=new Rule(-31, new int[]{135});
    rules[68]=new Rule(-15, new int[]{139,-10,-10});
    rules[69]=new Rule(-16, new int[]{140,-10});
    rules[70]=new Rule(-17, new int[]{141,-10});
    rules[71]=new Rule(-18, new int[]{142,-10});
    rules[72]=new Rule(-19, new int[]{143,-10,-10});
    rules[73]=new Rule(-20, new int[]{144,-10,-10,-10});
    rules[74]=new Rule(-21, new int[]{145,-8,-10});
    rules[75]=new Rule(-22, new int[]{146,-10,-23});
    rules[76]=new Rule(-22, new int[]{146,-10});
    rules[77]=new Rule(-23, new int[]{-24,-23});
    rules[78]=new Rule(-23, new int[]{-24});
    rules[79]=new Rule(-24, new int[]{129,-4,-11,130});
    rules[80]=new Rule(-25, new int[]{147,-10,-26});
    rules[81]=new Rule(-25, new int[]{147,-10});
    rules[82]=new Rule(-26, new int[]{-27,-26});
    rules[83]=new Rule(-26, new int[]{-27});
    rules[84]=new Rule(-27, new int[]{129,-4,46,-21,130});
    rules[85]=new Rule(-27, new int[]{129,-4,-21,130});
    rules[86]=new Rule(-2, new int[]{-29,-28});
    rules[87]=new Rule(-2, new int[]{-29});
    rules[88]=new Rule(-28, new int[]{-10,-28});
    rules[89]=new Rule(-28, new int[]{-10});
    rules[90]=new Rule(-29, new int[]{-4});
    rules[91]=new Rule(-29, new int[]{129,-21,130});
    rules[92]=new Rule(-29, new int[]{129,-22,130});
    rules[93]=new Rule(-29, new int[]{129,-25,130});
    rules[94]=new Rule(-1, new int[]{129,-25,130});
    rules[95]=new Rule(-1, new int[]{129,-22,130});
    rules[96]=new Rule(-1, new int[]{129,-21,130});

    nonTerminals = new string[] {"", "program", "callExp", "atom", "symbolic", 
      "numeric", "SExpression", "SExpressionList", "symbolicList", "symbolicSequence", 
      "exp", "expNoParen", "quoteExp", "eqExp", "aritExp", "leqExp", "carExp", 
      "cdrExp", "atomExp", "consExp", "ifExp", "lambdaExp", "letExp", "consPairList", 
      "consPair", "letrecExp", "consPairListRec", "consPairRec", "expList", "function", 
      "integer", "aritOp", "ReservedWord", "$accept", };
  }

  protected override void DoAction(int action)
  {
    switch (action)
    {
      case 2: // ReservedWord -> ADD 
{ yyval.TokenValue = Tokens.ADD; }
        break;
      case 3: // ReservedWord -> SUB 
{ yyval.TokenValue = Tokens.SUB; }
        break;
      case 4: // ReservedWord -> MUL 
{ yyval.TokenValue = Tokens.MUL; }
        break;
      case 5: // ReservedWord -> DIV 
{ yyval.TokenValue = Tokens.DIV; }
        break;
      case 6: // ReservedWord -> REM 
{ yyval.TokenValue = Tokens.REM; }
        break;
      case 7: // ReservedWord -> NIL 
{ yyval.TokenValue = Tokens.NIL; }
        break;
      case 8: // ReservedWord -> QUOTE 
{ yyval.TokenValue = Tokens.QUOTE; }
        break;
      case 9: // ReservedWord -> EQ 
{ yyval.TokenValue = Tokens.EQ; }
        break;
      case 10: // ReservedWord -> LEQ 
{ yyval.TokenValue = Tokens.LEQ; }
        break;
      case 11: // ReservedWord -> CAR 
{ yyval.TokenValue = Tokens.CAR; }
        break;
      case 12: // ReservedWord -> CDR 
{ yyval.TokenValue = Tokens.CDR; }
        break;
      case 13: // ReservedWord -> ATOM 
{ yyval.TokenValue = Tokens.ATOM; }
        break;
      case 14: // ReservedWord -> CONS 
{ yyval.TokenValue = Tokens.CONS; }
        break;
      case 15: // ReservedWord -> IF 
{ yyval.TokenValue = Tokens.IF; }
        break;
      case 16: // ReservedWord -> LAMBDA 
{ yyval.TokenValue = Tokens.LAMBDA; }
        break;
      case 17: // ReservedWord -> LET 
{ yyval.TokenValue = Tokens.LET; }
        break;
      case 18: // ReservedWord -> LETREC 
{ yyval.TokenValue = Tokens.LETREC; }
        break;
      case 19: // atom -> symbolic 
{
	Lispkit.Output.TraceMessage("Matching 'atom'");
	yyval.ObjectRef = new AtomNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 20: // atom -> numeric 
{
	Lispkit.Output.TraceMessage("Matching 'atom'");
	yyval.ObjectRef = new AtomNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 21: // symbolic -> IDENTIFIER 
{
	Lispkit.Output.TraceMessage("Matching 'symbolic'");
	yyval.ObjectRef = new SymbolicNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].StringValue);
}
        break;
      case 22: // numeric -> integer 
{
	Lispkit.Output.TraceMessage("Matching 'numeric'");
	yyval.ObjectRef = new NumericNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].IntValue);
}
        break;
      case 23: // integer -> INTEGER 
{
	Lispkit.Output.TraceMessage("Matching 'integer'");
	yyval.IntValue = value_stack.array[value_stack.top-1].IntValue;
}
        break;
      case 24: // SExpression -> atom 
{
	Lispkit.Output.TraceMessage("Matching 'SExpression'");	
	yyval.ObjectRef = new SExpressionNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 25: // SExpression -> LPAREN SExpressionList RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'SExpression'");	
	yyval.ObjectRef = new SExpressionNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 26: // SExpressionList -> SExpression 
{
	Lispkit.Output.TraceMessage("Matching 'SExpressionList'");	
	yyval.ObjectRef = new SExpressionListNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 27: // SExpressionList -> SExpression SExpressionList 
{
	Lispkit.Output.TraceMessage("Matching 'SExpressionList'");	
	yyval.ObjectRef = new SExpressionListNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 28: // symbolicList -> LPAREN RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'symbolicList'");	
	yyval.ObjectRef = new SymbolicListNode(this.LineNumber, this.ColumnNumber);
}
        break;
      case 29: // symbolicList -> LPAREN symbolicSequence RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'symbolicList'");	
	yyval.ObjectRef = new SymbolicListNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 30: // symbolicSequence -> symbolic 
{
	Lispkit.Output.TraceMessage("Matching 'symbolicSequence'");	
	yyval.ObjectRef = new SymbolicSequenceNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 31: // symbolicSequence -> symbolic symbolicSequence 
{
	Lispkit.Output.TraceMessage("Matching 'symbolicSequence'");	
	yyval.ObjectRef = new SymbolicSequenceNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 32: // exp -> symbolic 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 33: // exp -> LPAREN quoteExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 34: // exp -> LPAREN eqExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 35: // exp -> LPAREN leqExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 36: // exp -> LPAREN carExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 37: // exp -> LPAREN cdrExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 38: // exp -> LPAREN atomExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 39: // exp -> LPAREN consExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 40: // exp -> LPAREN ifExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 41: // exp -> LPAREN lambdaExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 42: // exp -> LPAREN letExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 43: // exp -> LPAREN letrecExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 44: // exp -> LPAREN callExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 45: // exp -> LPAREN aritExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 46: // expNoParen -> quoteExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 47: // expNoParen -> eqExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 48: // expNoParen -> leqExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 49: // expNoParen -> carExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 50: // expNoParen -> cdrExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 51: // expNoParen -> atomExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 52: // expNoParen -> consExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 53: // expNoParen -> ifExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 54: // expNoParen -> lambdaExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 55: // expNoParen -> letExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 56: // expNoParen -> letrecExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 57: // expNoParen -> callExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 58: // expNoParen -> aritExp 
{
	Lispkit.Output.TraceMessage("Matching 'exp'");	
	yyval.ObjectRef = new ExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 59: // quoteExp -> QUOTE SExpression 
{
	Lispkit.Output.TraceMessage("Matching 'quoteExp'");	
	yyval.ObjectRef = new QuoteExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 60: // quoteExp -> QUOTE ReservedWord 
{
	Lispkit.Output.TraceMessage("Matching 'quoteExp'");	
	yyval.ObjectRef = new QuoteExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].TokenValue);
}
        break;
      case 61: // eqExp -> EQ exp exp 
{
	Lispkit.Output.TraceMessage("Matching 'eqExp'");
	yyval.ObjectRef = new EqExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 62: // aritExp -> aritOp exp exp 
{
	Lispkit.Output.TraceMessage("Matching 'aritExp'");	
	yyval.ObjectRef = new AritExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef, value_stack.array[value_stack.top-3].Op);
}
        break;
      case 63: // aritOp -> ADD 
{
	Lispkit.Output.TraceMessage("Matching 'aritOp'");	
	yyval.Op = AritOp.Add;
}
        break;
      case 64: // aritOp -> SUB 
{
	Lispkit.Output.TraceMessage("Matching 'aritOp'");	
	yyval.Op = AritOp.Sub;
}
        break;
      case 65: // aritOp -> MUL 
{
	Lispkit.Output.TraceMessage("Matching 'aritOp'");	
	yyval.Op = AritOp.Mul;
}
        break;
      case 66: // aritOp -> DIV 
{
	Lispkit.Output.TraceMessage("Matching 'aritOp'");	
	yyval.Op = AritOp.Div;
}
        break;
      case 67: // aritOp -> REM 
{
	Lispkit.Output.TraceMessage("Matching 'aritOp'");	
	yyval.Op = AritOp.Rem;
}
        break;
      case 68: // leqExp -> LEQ exp exp 
{
	Lispkit.Output.TraceMessage("Matching 'leqExp'");	
	yyval.ObjectRef = new LeqExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 69: // carExp -> CAR exp 
{
	Lispkit.Output.TraceMessage("Matching 'carExp'");
	yyval.ObjectRef = new CarExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 70: // cdrExp -> CDR exp 
{
	Lispkit.Output.TraceMessage("Matching 'cdrExp'");
	yyval.ObjectRef = new CdrExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 71: // atomExp -> ATOM exp 
{
	Lispkit.Output.TraceMessage("Matching 'atomExp'");
	yyval.ObjectRef = new AtomExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 72: // consExp -> CONS exp exp 
{
	Lispkit.Output.TraceMessage("Matching 'consExp'");
	yyval.ObjectRef = new ConsExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 73: // ifExp -> IF exp exp exp 
{
	Lispkit.Output.TraceMessage("Matching 'ifExp'");
	yyval.ObjectRef = new IfExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-3].ObjectRef, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 74: // lambdaExp -> LAMBDA symbolicList exp 
{
	Lispkit.Output.TraceMessage("Matching 'lambdaExp'");
	yyval.ObjectRef = new LambdaExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 75: // letExp -> LET exp consPairList 
{
	Lispkit.Output.TraceMessage("Matching 'letExp'");
	yyval.ObjectRef = new LetExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 76: // letExp -> LET exp 
{
	Lispkit.Output.TraceMessage("Matching 'letExp'");
	yyval.ObjectRef = new LetExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 77: // consPairList -> consPair consPairList 
{
	Lispkit.Output.TraceMessage("Matching 'consPairList'");
	yyval.ObjectRef = new ConsPairListNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 78: // consPairList -> consPair 
{
	Lispkit.Output.TraceMessage("Matching 'consPairList'");
	yyval.ObjectRef = new ConsPairListNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 79: // consPair -> LPAREN symbolic expNoParen RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'consPair'");
	yyval.ObjectRef = new ConsPairNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-3].ObjectRef, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 80: // letrecExp -> LETREC exp consPairListRec 
{
	Lispkit.Output.TraceMessage("Matching 'letrecExp'");
	yyval.ObjectRef = new LetrecExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 81: // letrecExp -> LETREC exp 
{
	Lispkit.Output.TraceMessage("Matching 'letrecExp'");
	yyval.ObjectRef = new LetrecExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 82: // consPairListRec -> consPairRec consPairListRec 
{
	Lispkit.Output.TraceMessage("Matching 'consPairListRec'");
	yyval.ObjectRef = new ConsPairRecListNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 83: // consPairListRec -> consPairRec 
{
	Lispkit.Output.TraceMessage("Matching 'consPairListRec'");
	yyval.ObjectRef = new ConsPairRecListNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 84: // consPairRec -> LPAREN symbolic '.' lambdaExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'consPairRec'");
	yyval.ObjectRef = new ConsPairRecNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-4].ObjectRef, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 85: // consPairRec -> LPAREN symbolic lambdaExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'consPairRec'");
	yyval.ObjectRef = new ConsPairRecNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-3].ObjectRef, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 86: // callExp -> function expList 
{
	Lispkit.Output.TraceMessage("Matching 'callExp'");
	yyval.ObjectRef = new CallExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 87: // callExp -> function 
{
	Lispkit.Output.TraceMessage("Matching 'callExp'");
	yyval.ObjectRef = new CallExpNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 88: // expList -> exp expList 
{
	Lispkit.Output.TraceMessage("Matching 'expList'");
	yyval.ObjectRef = new ExpListNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 89: // expList -> exp 
{
	Lispkit.Output.TraceMessage("Matching 'expList'");	
	yyval.ObjectRef = new ExpListNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 90: // function -> symbolic 
{
	Lispkit.Output.TraceMessage("Matching 'function'");
	yyval.ObjectRef = new FunctionNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-1].ObjectRef);
}
        break;
      case 91: // function -> LPAREN lambdaExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'function'");
	yyval.ObjectRef = new FunctionNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 92: // function -> LPAREN letExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'function'");
	yyval.ObjectRef = new FunctionNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 93: // function -> LPAREN letrecExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'function'");
	yyval.ObjectRef = new FunctionNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
}
        break;
      case 94: // program -> LPAREN letrecExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'program'");
	yyval.ObjectRef = new ProgramNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
	this.astRootNode = yyval.ObjectRef;
}
        break;
      case 95: // program -> LPAREN letExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'program'");
	yyval.ObjectRef = new ProgramNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
	this.astRootNode = yyval.ObjectRef;
}
        break;
      case 96: // program -> LPAREN lambdaExp RPAREN 
{
	Lispkit.Output.TraceMessage("Matching 'program'");
	yyval.ObjectRef = new ProgramNode(this.LineNumber, this.ColumnNumber, value_stack.array[value_stack.top-2].ObjectRef);
	this.astRootNode = yyval.ObjectRef;
}
        break;
    }
  }

  protected override string TerminalToString(int terminal)
  {
    if (((Tokens)terminal).ToString() != terminal.ToString())
      return ((Tokens)terminal).ToString();
    else
      return CharToString((char)terminal);
  }


}
}
